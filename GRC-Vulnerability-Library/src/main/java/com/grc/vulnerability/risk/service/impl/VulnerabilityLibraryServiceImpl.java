package com.grc.vulnerability.risk.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import com.grc.vulnerability.common.constants.VulnerabilityLibraryConstants;
import com.grc.vulnerability.common.utils.ExcelHelper;
import com.grc.vulnerability.common.utils.MapperUtils;
import com.grc.vulnerability.risk.dao.VulnerabilityLibraryLogRepository;
import com.grc.vulnerability.risk.dao.VulnerabilityLibraryRepository;
import com.grc.vulnerability.risk.dto.VulnerabilityIdPreferenceDTO;
import com.grc.vulnerability.risk.dto.VulnerabilityLibraryDTO;
import com.grc.vulnerability.risk.entity.VulnerabilityLibrary;
import com.grc.vulnerability.risk.entity.VulnerabilityLibraryLog;
import com.grc.vulnerability.risk.entity.VulnerabilityPreference;
import com.grc.vulnerability.risk.exception.ResourceNotFoundException;
import com.grc.vulnerability.risk.service.VulnerabilityIdPreferenceService;
import com.grc.vulnerability.risk.service.VulnerabilityLibraryService;

@Service
public class VulnerabilityLibraryServiceImpl implements VulnerabilityLibraryService {

	@Autowired
	private VulnerabilityLibraryRepository vulnerabilityLibRepo;

	@Autowired
	private VulnerabilityLibraryLogRepository vulnerabilityLibLogRepo;

	@Autowired
	private VulnerabilityIdPreferenceService idPreference;

	private static final String VERSION_PREFIX = "ERM/";

	@Override
	public List<VulnerabilityLibrary> getAllVulnerability() {
		return this.vulnerabilityLibRepo.findAllVulnerability();
	}

	@Override
	public VulnerabilityLibrary getVulnerabilityById(long vulnerabilityId) {
		return vulnerabilityLibRepo.findById(vulnerabilityId)
				.orElseThrow(() -> new ResourceNotFoundException("Vulnerability not found with Vulnerability Id" + vulnerabilityId));
	}

	@Override
	public List<VulnerabilityLibraryDTO> getActiveVulnerabilityByList(List<Long> vulnerabilityIdList) {
		List<VulnerabilityLibraryDTO> vulnerabilityLibraryList = new ArrayList<>();
		for (long contDetalId : vulnerabilityIdList) {
			int count = vulnerabilityLibRepo.findByConut(contDetalId);
			if (count > 0) {
				VulnerabilityLibraryDTO detailVulnerability = MapperUtils.mapToTargetClass(getVulnerabilityById(contDetalId),
						VulnerabilityLibraryDTO.class);
				vulnerabilityLibraryList.add(detailVulnerability);
			}
		}
		return vulnerabilityLibraryList;
	}

	@Transactional
	@Override
	public String bulkVulnerabilityCreation(MultipartFile file, String uname) {
		List<Map<String, Object>> vulnerabilityDetails = ExcelHelper.getDetailsFromExcel(file,
				VulnerabilityLibraryConstants.BULK_UPLOAD_EXCEL_SHEET_NAME);
		List<VulnerabilityLibrary> vulnerabilityDetailsList = MapperUtils.mapToTargetClass(vulnerabilityDetails, VulnerabilityLibrary.class);
		List<VulnerabilityLibrary> vulnerabilityList = new ArrayList<>();

		for (VulnerabilityLibrary tempvulnerability : vulnerabilityDetailsList) {
			tempvulnerability.setCreatedBy(uname);
			tempvulnerability.setDeleteFlag("N");
			tempvulnerability.setActiveFlag("Y");
			VulnerabilityLibraryDTO vulnerabilityLibraryDto = MapperUtils.mapToTargetClass(tempvulnerability, VulnerabilityLibraryDTO.class);
			VulnerabilityLibrary vulnerabilityLibrary = createVulnerability(vulnerabilityLibraryDto);
			vulnerabilityList.add(vulnerabilityLibrary);
		}
		// List<VulnerabilityLibrary> savedList = saveAllVulnerability(vulnerabilityList);
		// List<VulnerabilityLibrary> savedList = saveAllVulnerability(vulnerabilityDetailsList);
		return StringUtils.replace(VulnerabilityLibraryConstants.BULK_CONTROL_UPLOAD_SUCCESS,
				VulnerabilityLibraryConstants.CURLY_BRACKETS_SYMBOL, Integer.toString(vulnerabilityList.size()));
	}

	public List<VulnerabilityLibrary> saveAllVulnerability(List<VulnerabilityLibrary> vulnerabilityLibraryAll) {
		return this.vulnerabilityLibRepo.saveAll(vulnerabilityLibraryAll);
	}

	@Transactional
	@Override
	public VulnerabilityLibrary createVulnerability(VulnerabilityLibraryDTO vulnerabilityLibrary) {
		VulnerabilityPreference preference = null;
		@SuppressWarnings("unused")
		String prefOrg = null, prefYear = null, uniqueIdPartOne = null, uniqueIdPartTwo = null;
		@SuppressWarnings("unused")
		String uniqueId = null, module = "Vulnerability Creation";

		int count = idPreference.getVulnerabilityIdPreferenceCountByActiveflag(module);
		int newCount = idPreference.findNewIdPreferenceCountByStatusFlag(module);
		if (count > 0) {
			preference = idPreference.getVulnerabilityIdPreferenceByModule(module);
		}

		if (preference.getPreferenceOganization() != null) {
			uniqueIdPartOne = preference.getPreferenceOganization() + "/";
		if (preference.getPreferenceYear() != null) {
				uniqueIdPartOne = uniqueIdPartOne + preference.getPreferenceYear() + "/";
			}
		} else if (preference.getPreferenceYear() != null) {
			uniqueIdPartOne = preference.getPreferenceYear() + "/";
		}
		uniqueIdPartTwo = generateNewVersion(preference, newCount);
		if (uniqueIdPartOne != null) {
			uniqueId = uniqueIdPartOne + uniqueIdPartTwo;
		} else {
			uniqueId = uniqueIdPartTwo;
		}
		// vulnerabilityLibrary.setStatus("Initiated");
		// System.out.println("Unique-Id++++++++++++++++++++++++++" + uniqueIdPartTwo);

		VulnerabilityLibrary vulnerabilitylib = MapperUtils.mapToTargetClass(vulnerabilityLibrary, VulnerabilityLibrary.class);
		vulnerabilitylib.setVulnerabilityUniqueId(uniqueIdPartTwo);
		if (preference.getPreferenceOganization() != null) {
			vulnerabilitylib.setPreferenceOganization(preference.getPreferenceOganization());
		}
		if (preference.getPreferenceYear() != null) {
			vulnerabilitylib.setPreferenceYear(preference.getPreferenceYear());
		}
		vulnerabilitylib.setDeleteFlag("N");
		vulnerabilitylib.setActiveFlag("Y");
		return this.vulnerabilityLibRepo.save(vulnerabilitylib);
	}

	public VulnerabilityLibraryLog updateVulnerabilityLog(long vulnerabilityId) {
		VulnerabilityLibrary existingVulnerability = getVulnerabilityById(vulnerabilityId);
		VulnerabilityLibraryLog vulnerabilitylib = MapperUtils.mapToTargetClass(existingVulnerability, VulnerabilityLibraryLog.class);
		return vulnerabilityLibLogRepo.save(vulnerabilitylib);
	}

	@Transactional
	@Override
	public VulnerabilityLibrary updateVulnerability(VulnerabilityLibraryDTO vulnerabilityLibrary) {
		@SuppressWarnings("unused")
		VulnerabilityLibraryLog log = updateVulnerabilityLog(vulnerabilityLibrary.getVulnerabilityId());
		VulnerabilityLibrary vulnerabilitylib = MapperUtils.mapToTargetClass(vulnerabilityLibrary, VulnerabilityLibrary.class);
		vulnerabilitylib.setDeleteFlag("N");
		vulnerabilitylib.setActiveFlag("Y");
		return vulnerabilityLibRepo.save(vulnerabilitylib);
	}

	public VulnerabilityLibrary updateDelete(VulnerabilityLibraryDTO vulnerabilityLibrary) {
		@SuppressWarnings("unused")
		VulnerabilityLibraryLog log = updateVulnerabilityLog(vulnerabilityLibrary.getVulnerabilityId());
		VulnerabilityLibrary existingVulnerability = getVulnerabilityById(vulnerabilityLibrary.getVulnerabilityId());
		existingVulnerability.setDeleteFlag("D");
		existingVulnerability.setActiveFlag("N");
		return vulnerabilityLibRepo.save(existingVulnerability);
	}

	@Transactional
	@Override
	public VulnerabilityLibrary deleteVulnerability(VulnerabilityLibraryDTO vulnerability) {
		@SuppressWarnings("unused")
		VulnerabilityLibraryLog log = updateVulnerabilityLog(vulnerability.getVulnerabilityId());
		VulnerabilityLibrary existingVulnerability = getVulnerabilityById(vulnerability.getVulnerabilityId());
		existingVulnerability.setDeleteFlag("D");
		existingVulnerability.setActiveFlag("N");
		return vulnerabilityLibRepo.save(existingVulnerability);
	}

	@Transactional
	@Override
	public String deleteVulnerabilityList(List<VulnerabilityLibraryDTO> vulnerabilityLibraryList, String username) {
		int count = 0;
		List<VulnerabilityLibrary> vulnerabilityList = null;
							vulnerabilityList = new ArrayList<>();
		for (VulnerabilityLibraryDTO vulnerabilityDetail : vulnerabilityLibraryList) {
			count = count + 1;
			@SuppressWarnings("unused")
			VulnerabilityLibraryLog log = updateVulnerabilityLog(vulnerabilityDetail.getVulnerabilityId());
			VulnerabilityLibrary existingVulnerability = getVulnerabilityById(vulnerabilityDetail.getVulnerabilityId());
			existingVulnerability.setModifiedBy(username);
			existingVulnerability.setDeleteFlag("D");
			existingVulnerability.setActiveFlag("N");
			vulnerabilityList.add(vulnerabilityLibRepo.save(existingVulnerability));
		}//vulnerabilityList.size()
		return StringUtils.replace(VulnerabilityLibraryConstants.CONTROL_LIST_DELETE_SUCCESS,
				VulnerabilityLibraryConstants.CURLY_BRACKETS_SYMBOL, Integer.toString(count));
	}

	private String generateNewVersion(VulnerabilityPreference idPref, int count) {
		String prefix = VERSION_PREFIX + idPref.getRunningSeries().trim() + "/";
		VulnerabilityLibrary vulnerabilityCreation = vulnerabilityLibRepo.findFirstByOrderByCreatedDateDescVulnerabilityIdDesc();
		int numberPartOfLastCreatedID = 0;
		if (count <= 0) {
			if (vulnerabilityCreation.getVulnerabilityUniqueId() != null) {
				String lastCreatedUniqueID = vulnerabilityCreation.getVulnerabilityUniqueId();
				Pattern pattern = Pattern.compile("\\d+");
				Matcher matcher = pattern.matcher(lastCreatedUniqueID);
				while (matcher.find()) {
					numberPartOfLastCreatedID = 0;
					numberPartOfLastCreatedID = Integer.parseInt(matcher.group());
				}
				// New ID
				int newVersionID = numberPartOfLastCreatedID + 1;
				return prefix + newVersionID;
			} else {
				return prefix + 1;
			}
		} else {
			String res = prefix + 1;
			idPref.setStatus("N");
			@SuppressWarnings("unused")
			VulnerabilityIdPreferenceDTO preference = idPreference.updateVulnerabilityIdPreference(
					MapperUtils.mapToTargetClass(idPref, VulnerabilityIdPreferenceDTO.class), "Admin");
			return res;
		}
	}

}
